<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monochrome Plum Harvest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: radial-gradient(circle at center, #2d1b3d, #1a0e24, #0f051a);
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e6d7ff;
            position: relative;
        }
        
        #gameWrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background: radial-gradient(circle at center, #2d1b3d, #1a0e24, #0f051a);
        }
        
        #livesDisplay {
            background: linear-gradient(145deg, #2d1b3d, #4a2c5a);
            border: 4px solid #9932cc;
            border-radius: 15px;
            padding: 15px 30px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 
                0 0 30px rgba(153, 50, 204, 0.3),
                inset 0 0 15px rgba(0,0,0,0.5);
        }
        
        #livesDisplay h2 {
            margin: 0;
            font-size: 24px;
            color: #e6d7ff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #livesCount {
            font-size: 28px;
            font-weight: bold;
            color: #ff6b9d;
            text-shadow: 0 0 8px rgba(255, 107, 157, 0.5);
        }
        
        #gameArea {
            display: flex;
            gap: 20px;
        }
        
        #tutorialPanel, #statsPanel {
            background: linear-gradient(145deg, #2d1b3d, #1a0e24);
            border: 4px solid #7b4397;
            border-radius: 20px;
            padding: 20px;
            width: 200px;
            height: 600px;
            box-shadow: 
                0 0 50px rgba(123, 67, 151, 0.2),
                inset 0 0 20px rgba(0,0,0,0.5);
            overflow-y: auto;
        }
        
        #gameContainer {
            background: linear-gradient(145deg, #2d1b3d, #1a0e24);
            border: 4px solid #da70d6;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 50px rgba(218, 112, 214, 0.3),
                inset 0 0 20px rgba(0,0,0,0.5);
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #f0e6ff 0%, #e6d7ff 20%, #dcc7ff 40%, #d1b3ff 60%, #c79fff 80%, #bd8bff 100%);
        }
        
        .stat-section {
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(145deg, #1a0e24, #2d1b3d);
            border: 2px solid #7b4397;
            border-radius: 12px;
        }
        
        .stat-section h3 {
            margin: 0 0 10px 0;
            color: #e6d7ff;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid #9932cc;
            padding-bottom: 5px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
            color: #d1b3ff;
        }
        
        .stat-bar {
            background: #2d1b3d;
            height: 4px;
            border-radius: 2px;
            margin: 2px 0;
            overflow: hidden;
        }
        
        .stat-fill {
            background: linear-gradient(90deg, #7b4397, #dc2430);
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #gameOver, #upgradeScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2d1b3d, #4a2c5a);
            border: 4px solid #da70d6;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            display: none;
            box-shadow: 
                0 15px 50px rgba(0,0,0,0.8),
                inset 0 0 30px rgba(218, 112, 214, 0.1);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .upgrade-category {
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(145deg, #1a0e24, #2d1b3d);
            border: 2px solid #7b4397;
            border-radius: 15px;
        }
        
        .upgrade-category h3 {
            color: #e6d7ff;
            margin: 0 0 15px 0;
            font-size: 18px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            border-bottom: 2px solid #9932cc;
            padding-bottom: 10px;
        }
        
        .upgrade-item {
            background: linear-gradient(145deg, #4a2c5a, #2d1b3d);
            border: 2px solid #7b4397;
            border-radius: 12px;
            padding: 18px;
            margin: 12px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .upgrade-item:hover {
            background: linear-gradient(145deg, #5a3c6a, #4a2c5a);
            transform: scale(1.02);
            box-shadow: 0 6px 15px rgba(218, 112, 214, 0.2);
        }
        
        .upgrade-item.affordable {
            border-color: #da70d6;
            box-shadow: 0 0 10px rgba(218, 112, 214, 0.3);
        }
        
        .upgrade-item.unaffordable {
            border-color: #7b4397;
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-item.maxed {
            border-color: #bd8bff;
            background: linear-gradient(145deg, #2d1b3d, #1a0e24);
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .upgrade-description {
            text-align: left;
            flex: 1;
            color: #d1b3ff;
        }
        
        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            color: #e6d7ff;
            margin-bottom: 5px;
        }
        
        .upgrade-effect {
            font-size: 12px;
            color: #bd8bff;
            margin-bottom: 3px;
        }
        
        .upgrade-cost {
            font-weight: bold;
            color: #ffd700;
            margin-left: 20px;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .upgrade-level {
            font-size: 11px;
            color: #9d7bbd;
        }
        
        button {
            background: linear-gradient(145deg, #7b4397, #4a2c5a);
            color: #e6d7ff;
            border: 2px solid #9932cc;
            padding: 15px 30px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            margin: 15px 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        button:hover {
            background: linear-gradient(145deg, #9b5cb7, #7b4397);
            border-color: #da70d6;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(218, 112, 214, 0.3);
        }
        
        .coins {
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.4);
        }
        
        .golden {
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }
        
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .combo-display {
            position: absolute;
            top: 80px;
            right: 20px;
            color: #da70d6;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        h2 {
            color: #e6d7ff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 20px;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a0e24;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #7b4397;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #9932cc;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="livesDisplay">
            <h2>Lives Left: <span id="livesCount">3</span></h2>
        </div>
    
    <div id="gameArea">
        <div id="tutorialPanel">
            <div class="stat-section">
                <h3>TUTORIAL GUIDE</h3>
                <div style="font-size: 11px; line-height: 1.4; color: #ccc;">
                    <div style="margin: 5px 0; padding: 3px 0; border-bottom: 1px solid #333;">
                        <strong style="color: #f5f5f5;">Controls:</strong><br>
                        Arrow Keys or A/D to move basket
                    </div>
                    <div style="margin: 5px 0; padding: 3px 0; border-bottom: 1px solid #333;">
                        <strong style="color: #9932cc;">Purple Plums:</strong><br>
                        +10 points, +1 coin<br>
                        Standard reward plums
                    </div>
                    <div style="margin: 5px 0; padding: 3px 0; border-bottom: 1px solid #333;">
                        <strong style="color: #ffd700;">Golden Plums:</strong><br>
                        +25 points, temporary boost<br>
                        10 second power-up duration
                    </div>
                    <div style="margin: 5px 0; padding: 3px 0; border-bottom: 1px solid #333;">
                        <strong style="color: #e63946;">Rotten Plums:</strong><br>
                        -20 points, breaks combo chain<br>
                        <em style="color: #888;">No life penalty</em>
                    </div>
                    <div style="margin: 5px 0; padding: 3px 0; border-bottom: 1px solid #333;">
                        <strong style="color: #999;">Gray Obstacles:</strong><br>
                        Lose 1 life, reset combo<br>
                        <em style="color: #888;">Avoid at all costs!</em>
                    </div>
                    <div style="margin: 5px 0; padding: 3px 0;">
                        <strong style="color: #f5f5f5;">Combo System:</strong><br>
                        Chain plum catches for score multipliers<br>
                        Higher combos = more coins & points
                    </div>
                </div>
            </div>
        </div>
        
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="particles" width="800" height="600"></canvas>
            
            <div id="comboDisplay" class="combo-display">COMBO x0</div>
            
            <div id="gameOver">
                <h2>⚰️ GAME TERMINATED ⚰️</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Coins Earned: <span id="coinsEarned" class="coins">0</span></p>
                <p>Best Combo: <span id="bestCombo">0</span></p>
                <button onclick="showUpgrades()">◈ UPGRADE FACILITY ◈</button>
                <button onclick="startGame()">◈ RESTART HARVEST ◈</button>
                <button onclick="resetSave()" style="background: linear-gradient(145deg, #e63946, #b71c1c); margin-top: 20px;">◈ RESET ALL PROGRESS ◈</button>
            </div>
            
            <div id="upgradeScreen">
                <h2>⬛ MONOCHROME UPGRADE LABORATORY ⬛</h2>
                <p>Research Points: <span id="totalCoins" class="coins">0</span></p>
                <div id="upgradeList"></div>
                <button onclick="startGame()">◈ DEPLOY UPGRADES ◈</button>
                <button onclick="hideUpgrades()">◈ RETURN ◈</button>
            </div>
        </div>
        
        <div id="statsPanel">
            <div class="stat-section">
                <h3>HIGH SCORES</h3>
                <div class="stat-row"><span>Best Score:</span> <span id="highScore" class="golden">0</span></div>
                <div class="stat-row"><span>Best Combo:</span> <span id="highCombo" class="golden">0</span></div>
                <div class="stat-row"><span>Total Coins:</span> <span id="lifetimeCoins" class="coins">0</span></div>
            </div>
            
            <div class="stat-section">
                <h3>CURRENT GAME</h3>
                <div class="stat-row"><span>Score:</span> <span id="statScore">0</span></div>
                <div class="stat-row"><span>Lives:</span> <span id="statLives">3</span></div>
                <div class="stat-row"><span>Level:</span> <span id="statLevel">1</span></div>
                <div class="stat-row"><span>Combo:</span> <span id="statCombo">0</span></div>
                <div class="stat-bar">
                    <div class="stat-fill" id="levelProgress" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="stat-section">
                <h3>RESOURCES</h3>
                <div class="stat-row"><span>Coins:</span> <span id="statCoins" class="coins">0</span></div>
                <div class="stat-row"><span>Multiplier:</span> <span id="statMultiplier">x1.0</span></div>
            </div>
            
            <div class="stat-section">
                <h3>ACTIVE BOOSTS</h3>
                <div id="boostDisplay">None Active</div>
            </div>
            
            <div class="stat-section">
                <h3>SESSION STATS</h3>
                <div class="stat-row"><span>Session Best:</span> <span id="sessionBest">0</span></div>
                <div class="stat-row"><span>Plums Caught:</span> <span id="sessionPlums">0</span></div>
                <div class="stat-row"><span>Games Played:</span> <span id="sessionGames">0</span></div>
            </div>
            
            <div class="stat-section">
                <h3>TECHNICAL STATS</h3>
                <div class="stat-row"><span>FPS:</span> <span id="fpsCounter">60</span></div>
                <div class="stat-row"><span>Objects:</span> <span id="objectCount">0</span></div>
                <div class="stat-row"><span>Particles:</span> <span id="particleCount">0</span></div>
            </div>
        </div>
    </div>

    <script>
        let gameState = {
            score: 0,
            lives: 3,
            coins: 0,
            totalCoins: 0,
            highScore: 0,
            highCombo: 0,
            lifetimeCoins: 0,
            sessionBest: 0,
            level: 1,
            combo: 0,
            maxCombo: 0,
            sessionMaxCombo: 0,
            sessionPlums: 0,
            sessionGames: 0,
            multiplier: 1.0,
            comboTimer: 0,
            isRunning: false,
            activeBoosts: {
                speed: 0,
                size: 0,
                magnet: 0,
                shield: 0,
                slowMotion: 0,
                cursed: 0
            },
            player: {
                x: 375,
                y: 520,
                width: 50,
                height: 30,
                speed: 5,
                invulnerable: 0
            },
            plums: [],
            obstacles: [],
            specialPlums: [],
            particles: [],
            splashParticles: [],
            keys: {},
            timers: {
                plumSpawn: 0,
                obstacleSpawn: 0,
                specialSpawn: 0,
                levelUp: 0
            },
            frameCount: 0,
            lastTime: performance.now()
        };
        
        // Cookie-based save system
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
        }
        
        function getCookie(name) {
            const nameEQ = name + "=";
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                cookie = cookie.trim();
                if (cookie.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(cookie.substring(nameEQ.length));
                }
            }
            return null;
        }
        
        function deleteCookie(name) {
            document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;
        }
        
        function saveGame() {
            const saveData = {
                coins: gameState.coins,
                totalCoins: gameState.totalCoins,
                highScore: gameState.highScore,
                highCombo: gameState.highCombo,
                lifetimeCoins: gameState.lifetimeCoins,
                sessionMaxCombo: gameState.sessionMaxCombo,
                sessionPlums: gameState.sessionPlums,
                sessionGames: gameState.sessionGames,
                upgrades: JSON.parse(JSON.stringify(upgrades))
            };
            setCookie('plumHarvestSave', JSON.stringify(saveData));
        }
        
        function loadGame() {
            const savedData = getCookie('plumHarvestSave');
            if (savedData) {
                try {
                    const saveData = JSON.parse(savedData);
                    gameState.coins = saveData.coins || 0;
                    gameState.totalCoins = saveData.totalCoins || 0;
                    gameState.highScore = saveData.highScore || 0;
                    gameState.highCombo = saveData.highCombo || 0;
                    gameState.lifetimeCoins = saveData.lifetimeCoins || 0;
                    gameState.sessionMaxCombo = saveData.sessionMaxCombo || 0;
                    gameState.sessionPlums = saveData.sessionPlums || 0;
                    gameState.sessionGames = saveData.sessionGames || 0;
                    
                    if (saveData.upgrades) {
                        Object.keys(saveData.upgrades).forEach(key => {
                            if (upgrades[key]) {
                                upgrades[key].level = saveData.upgrades[key].level || 0;
                            }
                        });
                    }
                } catch (e) {
                    console.log('Error loading save data:', e);
                }
            }
        }
        
        function resetSave() {
            if (confirm('Are you sure you want to reset ALL progress? This cannot be undone!')) {
                deleteCookie('plumHarvestSave');
                // Reset all game state
                gameState.coins = 0;
                gameState.totalCoins = 0;
                gameState.highScore = 0;
                gameState.highCombo = 0;
                gameState.lifetimeCoins = 0;
                gameState.sessionMaxCombo = 0;
                gameState.sessionPlums = 0;
                gameState.sessionGames = 0;
                
                // Reset upgrades
                Object.keys(upgrades).forEach(key => {
                    upgrades[key].level = 0;
                });
                
                updateUI();
                alert('All progress has been reset!');
            }
        }
        
        let upgrades = {
            // Movement Category
            speed: { level: 0, maxLevel: 10 },
            agility: { level: 0, maxLevel: 5 },
            
            // Basket Category  
            size: { level: 0, maxLevel: 8 },
            reinforcement: { level: 0, maxLevel: 5 },
            
            // Survival Category
            lives: { level: 0, maxLevel: 6 },
            shield: { level: 0, maxLevel: 8 },
            regeneration: { level: 0, maxLevel: 3 },
            
            // Collection Category
            magnet: { level: 0, maxLevel: 7 },
            vacuum: { level: 0, maxLevel: 4 },
            precision: { level: 0, maxLevel: 5 },
            
            // Economic Category
            coinBonus: { level: 0, maxLevel: 8 },
            comboMaster: { level: 0, maxLevel: 6 },
            efficiency: { level: 0, maxLevel: 4 },
            
            // Special Category
            timeWarp: { level: 0, maxLevel: 3 },
            ghostMode: { level: 0, maxLevel: 4 },
            destroyer: { level: 0, maxLevel: 5 }
        };
        
        const upgradeData = {
            // Movement
            speed: {
                name: "Velocity Enhancer",
                description: "Increases basket movement speed",
                category: "Movement",
                baseCost: 40,
                effect: (level) => gameState.player.speed = 5 + level * 1.2
            },
            agility: {
                name: "Micro-Adjustments",
                description: "Reduces movement delay and improves responsiveness",
                category: "Movement", 
                baseCost: 120,
                effect: (level) => {} // Applied in controls
            },
            
            // Basket
            size: {
                name: "Expansion Module",
                description: "Increases basket collection area",
                category: "Basket",
                baseCost: 60,
                effect: (level) => {
                    gameState.player.width = 50 + level * 8;
                    gameState.player.height = 30 + level * 3;
                }
            },
            reinforcement: {
                name: "Structural Integrity",
                description: "Basket becomes more resistant to damage",
                category: "Basket",
                baseCost: 100,
                effect: (level) => {} // Applied in collision
            },
            
            // Survival
            lives: {
                name: "Backup Systems",
                description: "Additional life support units",
                category: "Survival",
                baseCost: 80,
                effect: (level) => gameState.lives = Math.max(gameState.lives, 3 + level)
            },
            shield: {
                name: "Deflector Array",
                description: "Chance to deflect incoming obstacles",
                category: "Survival",
                baseCost: 150,
                effect: (level) => {} // Applied in collision
            },
            regeneration: {
                name: "Auto-Repair Protocol",
                description: "Slowly regenerates lost lives over time",
                category: "Survival",
                baseCost: 300,
                effect: (level) => {} // Applied in game loop
            },
            
            // Collection
            magnet: {
                name: "Magnetic Field Generator",
                description: "Attracts plums from greater distances",
                category: "Collection",
                baseCost: 100,
                effect: (level) => {} // Applied in plum update
            },
            vacuum: {
                name: "Gravitational Collector",
                description: "Creates suction effect for nearby plums",
                category: "Collection",
                baseCost: 250,
                effect: (level) => {} // Applied in plum update
            },
            precision: {
                name: "Targeting System",
                description: "Improved collision detection for edge catches",
                category: "Collection",
                baseCost: 180,
                effect: (level) => {} // Applied in collision
            },
            
            // Economic
            coinBonus: {
                name: "Value Multiplier",
                description: "Increases coins earned per plum",
                category: "Economic",
                baseCost: 70,
                effect: (level) => {}
            },
            comboMaster: {
                name: "Combo Sustainer",
                description: "Maintains combos longer and increases multipliers",
                category: "Economic", 
                baseCost: 200,
                effect: (level) => {}
            },
            efficiency: {
                name: "Resource Optimizer",
                description: "Chance for bonus coins on any action",
                category: "Economic",
                baseCost: 160,
                effect: (level) => {}
            },
            
            // Special
            timeWarp: {
                name: "Temporal Distortion",
                description: "Occasionally slows down time briefly",
                category: "Special",
                baseCost: 400,
                effect: (level) => {}
            },
            ghostMode: {
                name: "Phase Shifter",
                description: "Brief invulnerability periods after taking damage",
                category: "Special",
                baseCost: 350,
                effect: (level) => {}
            },
            destroyer: {
                name: "Obstacle Annihilator",
                description: "Chance to destroy obstacles on contact",
                category: "Special",
                baseCost: 500,
                effect: (level) => {}
            }
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const particleCanvas = document.getElementById('particles');
        const particleCtx = particleCanvas.getContext('2d');
        
        // Audio System
        let audioContext;
        let masterVolume = 0.3;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Audio not supported');
                audioContext = null;
            }
        }
        
        function playSound(type, frequency = 440, duration = 0.1, volume = 0.5) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'plumCatch':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, now);
                    oscillator.frequency.exponentialRampToValueAtTime(frequency * 1.5, now + duration);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'goldenPlum':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(660, now);
                    oscillator.frequency.linearRampToValueAtTime(880, now + duration/2);
                    oscillator.frequency.linearRampToValueAtTime(1100, now + duration);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'rottenPlum':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + duration);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'obstacle':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'boost':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, now);
                    oscillator.frequency.exponentialRampToValueAtTime(880, now + duration/2);
                    oscillator.frequency.exponentialRampToValueAtTime(1320, now + duration);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'levelUp':
                    oscillator.type = 'triangle';
                    const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    notes.forEach((note, i) => {
                        oscillator.frequency.setValueAtTime(note, now + (i * duration/4));
                    });
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
                    
                case 'combo':
                    oscillator.type = 'sine';
                    const comboFreq = 440 + (gameState.combo * 20);
                    oscillator.frequency.value = Math.min(comboFreq, 1200);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume * masterVolume * 0.7, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    break;
            }
            
            oscillator.start(now);
            oscillator.stop(now + duration);
        }
        
        function playAmbientTone() {
            if (!audioContext || !gameState.isRunning) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 110 + (gameState.level * 5); // Subtle pitch increase per level
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 200;
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(masterVolume * 0.1, audioContext.currentTime + 2);
            
            oscillator.start();
            
            // Stop after 3 seconds and schedule next one
            setTimeout(() => {
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.stop(audioContext.currentTime + 1);
                
                // Schedule next ambient tone
                if (gameState.isRunning) {
                    setTimeout(playAmbientTone, Math.random() * 5000 + 3000); // 3-8 seconds
                }
            }, 2000);
        }
        
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            // Initialize audio context on first user interaction
            if (!audioContext) {
                initAudio();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });
        
        // Initialize audio on first click too
        document.addEventListener('click', () => {
            if (!audioContext) {
                initAudio();
            }
        });
        
        function applyUpgrades() {
            Object.keys(upgrades).forEach(key => {
                if (upgradeData[key]) {
                    upgradeData[key].effect(upgrades[key].level);
                }
            });
        }
        
        function createSplashParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = 2 + Math.random() * 3;
                gameState.splashParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    color: color,
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        function createParticle(x, y, type = 'coin', color = '#f5f5f5') {
            const count = type === 'explosion' ? 15 : 5;
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x + Math.random() * 20 - 10,
                    y: y + Math.random() * 20 - 10,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 40 + Math.random() * 20,
                    maxLife: 60,
                    color: color,
                    type: type,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        function updateParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            // Update regular particles
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15;
                p.vx *= 0.98;
                p.life--;
                
                const alpha = p.life / p.maxLife;
                particleCtx.globalAlpha = alpha;
                particleCtx.fillStyle = p.color;
                
                if (p.type === 'coin') {
                    particleCtx.fillRect(p.x, p.y, p.size, p.size);
                } else if (p.type === 'explosion') {
                    particleCtx.beginPath();
                    particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    particleCtx.fill();
                } else {
                    particleCtx.fillRect(p.x, p.y, p.size, p.size);
                }
                
                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
            
            // Update splash particles
            for (let i = gameState.splashParticles.length - 1; i >= 0; i--) {
                const p = gameState.splashParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.vx *= 0.95;
                p.life--;
                
                const alpha = p.life / p.maxLife;
                particleCtx.globalAlpha = alpha;
                particleCtx.fillStyle = p.color;
                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particleCtx.fill();
                
                if (p.life <= 0) {
                    gameState.splashParticles.splice(i, 1);
                }
            }
            
            particleCtx.globalAlpha = 1;
        }
        
        function drawPlayer() {
            const p = gameState.player;
            
            // Apply size boost
            let width = p.width;
            let height = p.height;
            let x = p.x;
            let y = p.y;
            
            if (gameState.activeBoosts.size > 0) {
                const oldWidth = width;
                width *= 1.5;
                height *= 1.5;
                x -= (width - oldWidth) / 2;
                y -= (height - p.height) / 2;
            }
            
            // Curse visual effects
            if (gameState.activeBoosts.cursed > 0) {
                ctx.globalAlpha = 0.7 + 0.3 * Math.sin(Date.now() * 0.02);
                ctx.fillStyle = 'rgba(230, 57, 70, 0.2)';
                ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
            }
            
            // Invulnerability effect
            if (p.invulnerable > 0) {
                ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
            }
            
            // Shield effect
            if ((upgrades.shield.level > 0 && Math.random() < 0.05) || gameState.activeBoosts.shield > 0) {
                const shieldAlpha = gameState.activeBoosts.shield > 0 ? 0.8 : 0.3;
                ctx.strokeStyle = `rgba(153, 50, 204, ${shieldAlpha})`;
                ctx.lineWidth = 2 + upgrades.shield.level + (gameState.activeBoosts.shield > 0 ? 3 : 0);
                ctx.strokeRect(x - 10, y - 10, width + 20, height + 20);
            }
            
            // Basket body
            const gradient = ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(0.3, '#d0d0d0');
            gradient.addColorStop(0.7, '#a0a0a0');
            gradient.addColorStop(1, '#707070');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);
            
            // Basket rim
            ctx.fillStyle = '#404040';
            ctx.fillRect(x, y, width, 6);
            
            // Basket weave pattern
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 1;
            const sections = Math.floor(width / 12);
            for (let i = 1; i < sections; i++) {
                ctx.beginPath();
                ctx.moveTo(x + (i * width / sections), y);
                ctx.lineTo(x + (i * width / sections), y + height);
                ctx.stroke();
            }
            
            // Horizontal weave lines
            for (let i = 1; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y + (i * height / 4));
                ctx.lineTo(x + width, y + (i * height / 4));
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function drawPlum(plum) {
            const size = plum.special ? 25 : (plum.golden ? 22 : 20);
            const centerX = plum.x + size / 2;
            const centerY = plum.y + size / 2;
            
            // Special effects for different plum types
            if (plum.special) {
                // Special plum - animated with rings
                const time = Date.now() * 0.005;
                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = `rgba(153, 50, 204, ${0.5 - i * 0.15})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size/2 + Math.sin(time + i) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else if (plum.golden) {
                // Golden plum - golden glow
                const time = Date.now() * 0.008;
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.8 + Math.sin(time) * 0.2})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size/2 + 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner glow
                ctx.strokeStyle = `rgba(255, 215, 0, 0.4)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size/2 + 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Choose colors based on plum type
            let colors;
            if (plum.rotten) {
                colors = {
                    highlight: '#ff6b6b',
                    mid1: '#e63946',
                    mid2: '#a4161a',
                    shadow: '#660708',
                    crease: '#370617'
                };
            } else if (plum.golden) {
                colors = {
                    highlight: '#fff700',
                    mid1: '#ffd700',
                    mid2: '#ffb000',
                    shadow: '#cc8400',
                    crease: '#995500'
                };
            } else {
                // Regular purple plum
                colors = {
                    highlight: '#e6e6fa',
                    mid1: '#da70d6',
                    mid2: '#9932cc',
                    shadow: '#4b0082',
                    crease: '#2e0249'
                };
            }
            
            // Main plum body with gradient
            const gradient = ctx.createRadialGradient(centerX - 3, centerY - 3, 2, centerX, centerY, size/2);
            gradient.addColorStop(0, colors.highlight);
            gradient.addColorStop(0.3, colors.mid1);
            gradient.addColorStop(0.7, colors.mid2);
            gradient.addColorStop(1, colors.shadow);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Plum crease
            ctx.fillStyle = colors.crease;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY - size/4, 2, size/3, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(centerX - size/4, centerY - size/4, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Additional effects for rotten plums
            if (plum.rotten) {
                ctx.fillStyle = 'rgba(103, 7, 8, 0.6)';
                ctx.beginPath();
                ctx.arc(centerX + size/6, centerY + size/6, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(centerX - size/5, centerY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawObstacle(obstacle) {
            // Main obstacle body
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            
            // Highlight edges
            ctx.fillStyle = '#666';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 3);
            ctx.fillRect(obstacle.x, obstacle.y, 3, obstacle.height);
            
            // Dark shadows
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(obstacle.x + obstacle.width - 3, obstacle.y, 3, obstacle.height);
            ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 3, obstacle.width, 3);
            
            // Center highlight
            ctx.fillStyle = '#404040';
            ctx.fillRect(obstacle.x + 6, obstacle.y + 6, obstacle.width - 12, obstacle.height - 12);
        }
        
        function updatePlayer() {
            const p = gameState.player;
            if (p.invulnerable > 0) p.invulnerable--;
            
            let speedMultiplier = 1 + upgrades.agility.level * 0.2;
            
            if (gameState.activeBoosts.speed > 0) {
                speedMultiplier *= 2.0;
            }
            
            if (gameState.activeBoosts.cursed > 0) {
                speedMultiplier *= 0.5;
                if (Math.random() < 0.02) {
                    p.x += (Math.random() - 0.5) * 20;
                    p.x = Math.max(0, Math.min(canvas.width - p.width, p.x));
                }
            }
            
            if (gameState.keys['ArrowLeft'] || gameState.keys['a'] || gameState.keys['A']) {
                p.x = Math.max(0, p.x - p.speed * speedMultiplier);
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['d'] || gameState.keys['D']) {
                p.x = Math.min(canvas.width - p.width, p.x + p.speed * speedMultiplier);
            }
        }
        
        function spawnPlum() {
            const rand = Math.random();
            let special = false;
            let rotten = false;
            let golden = false;
            let powerup = null;
            let value = 100;
            
            // Plum type probabilities
            if (rand < 0.08) { // 8% chance for golden plum
                golden = true;
                value = 25;
                const powerups = ['speed', 'size', 'magnet', 'shield', 'slowMotion'];
                powerup = powerups[Math.floor(Math.random() * powerups.length)];
            } else if (rand < 0.18) { // 10% chance for rotten plum
                rotten = true;
                value = -20;
            } else if (rand < 0.28) { // 10% chance for special plum
                special = true;
                value = 50;
                const powerups = ['speed', 'size', 'magnet', 'shield', 'slowMotion'];
                powerup = powerups[Math.floor(Math.random() * powerups.length)];
            }
            
            const baseSpeed = 0.8;
            const levelSpeedIncrease = 0.4;
            const randomVariation = Math.random() * 0.6;
            const finalSpeed = baseSpeed + (gameState.level - 1) * levelSpeedIncrease + randomVariation;
            
            gameState.plums.push({
                x: Math.random() * (canvas.width - 25),
                y: -25,
                width: special || golden ? 25 : 20,
                height: special || golden ? 25 : 20,
                speed: finalSpeed,
                special: special,
                rotten: rotten,
                golden: golden,
                powerup: powerup,
                value: value
            });
        }
        
        function spawnObstacle() {
            const baseSpeed = 1.2;
            const levelSpeedIncrease = 0.3;
            const randomVariation = Math.random() * 0.8;
            const finalSpeed = baseSpeed + (gameState.level - 1) * levelSpeedIncrease + randomVariation;
            
            gameState.obstacles.push({
                x: Math.random() * (canvas.width - 35),
                y: -35,
                width: 30 + Math.random() * 10,
                height: 30 + Math.random() * 10,
                speed: finalSpeed
            });
        }
        
        function activateBoost(type, duration = 600) {
            gameState.activeBoosts[type] = duration;
            createParticle(gameState.player.x + 25, gameState.player.y, 'explosion', '#9932cc');
        }
        
        function updatePlums() {
            for (let i = gameState.plums.length - 1; i >= 0; i--) {
                const plum = gameState.plums[i];
                
                // Magnet effects
                if (upgrades.magnet.level > 0 || upgrades.vacuum.level > 0 || gameState.activeBoosts.magnet > 0) {
                    let magnetRange = 60 + upgrades.magnet.level * 20 + upgrades.vacuum.level * 30;
                    if (gameState.activeBoosts.magnet > 0) {
                        magnetRange *= 2.5;
                    }
                    
                    const dx = (gameState.player.x + gameState.player.width / 2) - (plum.x + plum.width / 2);
                    const dy = gameState.player.y - plum.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < magnetRange) {
                        let magnetStrength = 0.2 + upgrades.magnet.level * 0.15 + upgrades.vacuum.level * 0.25;
                        if (gameState.activeBoosts.magnet > 0) {
                            magnetStrength *= 2.0;
                        }
                        plum.x += (dx / distance) * magnetStrength;
                        plum.y += (dy / distance) * magnetStrength * 0.4;
                    }
                }
                
                plum.y += plum.speed;
                
                // Collision detection
                const precisionBonus = upgrades.precision.level * 5;
                let collisionMargin = precisionBonus;
                
                let basketWidth = gameState.player.width;
                let basketHeight = gameState.player.height;
                let basketX = gameState.player.x;
                let basketY = gameState.player.y;
                
                if (gameState.activeBoosts.size > 0) {
                    const oldWidth = basketWidth;
                    basketWidth *= 1.5;
                    basketHeight *= 1.5;
                    basketX -= (basketWidth - oldWidth) / 2;
                    basketY -= (basketHeight - gameState.player.height) / 2;
                }
                
                if (plum.x < basketX + basketWidth + collisionMargin &&
                    plum.x + plum.width > basketX - collisionMargin &&
                    plum.y < basketY + basketHeight + collisionMargin &&
                    plum.y + plum.height > basketY - collisionMargin) {
                    
                    // Plum caught!
                    gameState.sessionPlums++;
                    gameState.combo++;
                    gameState.comboTimer = 180 + upgrades.comboMaster.level * 30;
                    gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                    gameState.sessionMaxCombo = Math.max(gameState.sessionMaxCombo, gameState.combo);
                    
                    gameState.multiplier = 1.0 + (gameState.combo * 0.1) + (upgrades.comboMaster.level * 0.05);
                    
                    const baseScore = plum.value;
                    const finalScore = Math.floor(baseScore * gameState.multiplier);
                    gameState.score += finalScore;
                    
                    const baseCoinReward = 1 + upgrades.coinBonus.level;
                    let coinReward = Math.floor(baseCoinReward * gameState.multiplier);
                    
                    // Play sound effects based on plum type
                    if (plum.golden) {
                        playSound('goldenPlum', 660, 0.4, 0.5);
                    } else if (plum.rotten) {
                        playSound('rottenPlum', 200, 0.3, 0.4);
                    } else if (plum.special) {
                        playSound('plumCatch', 660, 0.2, 0.5);
                    } else {
                        // Regular plum - pitch based on combo
                        const comboPitch = 440 + (gameState.combo * 30);
                        playSound('plumCatch', Math.min(comboPitch, 880), 0.15, 0.4);
                    }
                    
                    // Combo sound
                    if (gameState.combo > 1) {
                        playSound('combo', 0, 0.1, 0.3);
                    }
                    
                    if (upgrades.efficiency.level > 0 && Math.random() < upgrades.efficiency.level * 0.15) {
                        coinReward *= 2;
                    }
                    
                    gameState.coins += coinReward;
                    gameState.totalCoins += coinReward;
                    
                    // Create splash particles for all plums
                    let splashColor = '#9932cc';
                    if (plum.rotten) splashColor = '#e63946';
                    else if (plum.golden) splashColor = '#ffd700';
                    else if (plum.special) splashColor = '#ffffff';
                    
                    createSplashParticles(plum.x + plum.width/2, plum.y + plum.height/2, splashColor, 12);
                    
                    // Activate powerups
                    if (plum.powerup) {
                        let duration = 600; // 10 seconds base
                        if (plum.golden) duration = 600; // 10 seconds for golden
                        else if (plum.special) duration = 300; // 5 seconds for regular special
                        
                        activateBoost(plum.powerup, duration);
                        playSound('boost', 0, 0.3, 0.4);
                    }
                    
                    // Show combo display
                    if (gameState.combo > 1) {
                        const comboDisplay = document.getElementById('comboDisplay');
                        comboDisplay.textContent = `COMBO x${gameState.combo}`;
                        comboDisplay.style.opacity = '1';
                        setTimeout(() => {
                            comboDisplay.style.opacity = '0';
                        }, 1000);
                    }
                    
                    gameState.plums.splice(i, 1);
                    continue;
                }
                
                // Plum falls off screen
                if (plum.y > canvas.height) {
                    if (!plum.rotten) {
                        gameState.lives--;
                        gameState.combo = 0;
                        gameState.multiplier = 1.0;
                        createParticle(plum.x + 10, canvas.height - 20, 'explosion', '#808080');
                        
                        if (gameState.lives <= 0) {
                            endGame();
                            return;
                        }
                    } else {
                        gameState.combo = Math.max(0, gameState.combo - 1);
                        gameState.multiplier = Math.max(1.0, gameState.multiplier - 0.1);
                        createParticle(plum.x + 10, canvas.height - 20, 'explosion', '#e63946');
                    }
                    
                    gameState.plums.splice(i, 1);
                }
            }
        }
        
        function updateObstacles() {
            for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                const obstacle = gameState.obstacles[i];
                obstacle.y += obstacle.speed;
                
                let basketWidth = gameState.player.width;
                let basketHeight = gameState.player.height;
                let basketX = gameState.player.x;
                let basketY = gameState.player.y;
                
                if (gameState.activeBoosts.size > 0) {
                    const oldWidth = basketWidth;
                    basketWidth *= 1.5;
                    basketHeight *= 1.5;
                    basketX -= (basketWidth - oldWidth) / 2;
                    basketY -= (basketHeight - gameState.player.height) / 2;
                }
                
                if (obstacle.x < basketX + basketWidth &&
                    obstacle.x + obstacle.width > basketX &&
                    obstacle.y < basketY + basketHeight &&
                    obstacle.y + obstacle.height > basketY) {
                    
                    if (gameState.player.invulnerable > 0) {
                        continue;
                    }
                    
                    // Destroyer upgrade
                    if (upgrades.destroyer.level > 0 && Math.random() < upgrades.destroyer.level * 0.2) {
                        createParticle(obstacle.x + 15, obstacle.y + 15, 'explosion', '#f5f5f5');
                        gameState.obstacles.splice(i, 1);
                        continue;
                    }
                    
                    // Shield chance
                    let shieldChance = upgrades.shield.level * 0.12;
                    if (gameState.activeBoosts.shield > 0) {
                        shieldChance += 0.5;
                    }
                    
                    if (Math.random() < shieldChance) {
                        createParticle(obstacle.x + 15, obstacle.y + 15, 'explosion', '#9932cc');
                        gameState.obstacles.splice(i, 1);
                        continue;
                    }
                    
                    // Reinforcement reduces damage chance
                    const damageReduction = upgrades.reinforcement.level * 0.15;
                    if (Math.random() < damageReduction) {
                        createParticle(obstacle.x + 15, obstacle.y + 15, 'coin', '#a0a0a0');
                        gameState.obstacles.splice(i, 1);
                        continue;
                    }
                    
                    // Take damage
                    gameState.lives--;
                    gameState.combo = 0;
                    gameState.multiplier = 1.0;
                    gameState.obstacles.splice(i, 1);
                    
                    // Play obstacle hit sound
                    playSound('obstacle', 0, 0.2, 0.6);
                    
                    if (upgrades.ghostMode.level > 0) {
                        gameState.player.invulnerable = 60 + upgrades.ghostMode.level * 30;
                    }
                    
                    createParticle(obstacle.x + 15, obstacle.y + 15, 'explosion', '#404040');
                    
                    if (gameState.lives <= 0) {
                        endGame();
                        return;
                    }
                }
                
                if (obstacle.y > canvas.height) {
                    gameState.obstacles.splice(i, 1);
                }
            }
        }
        
        function updateUI() {
            // Update top lives display
            document.getElementById('livesCount').textContent = gameState.lives;
            
            // Update stats panel
            document.getElementById('statScore').textContent = gameState.score.toLocaleString();
            document.getElementById('statLives').textContent = gameState.lives;
            document.getElementById('statLevel').textContent = gameState.level;
            document.getElementById('statCombo').textContent = gameState.combo;
            document.getElementById('statCoins').textContent = gameState.coins.toLocaleString();
            document.getElementById('statMultiplier').textContent = 'x' + gameState.multiplier.toFixed(1);
            
            // Update high scores
            document.getElementById('highScore').textContent = gameState.highScore.toLocaleString();
            document.getElementById('highCombo').textContent = gameState.highCombo;
            document.getElementById('lifetimeCoins').textContent = gameState.lifetimeCoins.toLocaleString();
            
            // Update session stats
            document.getElementById('sessionBest').textContent = gameState.sessionBest.toLocaleString();
            document.getElementById('sessionPlums').textContent = gameState.sessionPlums;
            document.getElementById('sessionGames').textContent = gameState.sessionGames;
            
            // Update technical stats
            const currentTime = performance.now();
            gameState.frameCount++;
            if (currentTime - gameState.lastTime >= 1000) {
                const fps = Math.round((gameState.frameCount * 1000) / (currentTime - gameState.lastTime));
                document.getElementById('fpsCounter').textContent = fps;
                gameState.frameCount = 0;
                gameState.lastTime = currentTime;
            }
            
            const totalObjects = gameState.plums.length + gameState.obstacles.length;
            const totalParticles = gameState.particles.length + gameState.splashParticles.length;
            document.getElementById('objectCount').textContent = totalObjects;
            document.getElementById('particleCount').textContent = totalParticles;
            
            // Update boost display
            const boostDisplay = document.getElementById('boostDisplay');
            const activeBoosts = Object.keys(gameState.activeBoosts).filter(
                boost => gameState.activeBoosts[boost] > 0
            );
            
            if (activeBoosts.length > 0) {
                boostDisplay.innerHTML = activeBoosts.map(boost => {
                    const timeLeft = Math.ceil(gameState.activeBoosts[boost] / 60);
                    const color = boost === 'cursed' ? '#e63946' : '#9932cc';
                    return `<div style="color: ${color}; font-size: 11px; margin: 2px 0;">${boost.toUpperCase()}: ${timeLeft}s</div>`;
                }).join('');
            } else {
                boostDisplay.innerHTML = '<div style="color: #666; font-size: 11px;">None Active</div>';
            }
        }
        
        function gameLoop(currentTime = performance.now()) {
            if (!gameState.isRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Time effects
            let timeMultiplier = 1.0;
            if (gameState.activeBoosts.slowMotion > 0) {
                timeMultiplier = 0.4;
                ctx.fillStyle = 'rgba(153, 50, 204, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (upgrades.timeWarp.level > 0 && Math.random() < 0.002 * upgrades.timeWarp.level) {
                timeMultiplier = 0.3;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            updatePlayer();
            updatePlums();
            updateObstacles();
            updateParticles();
            
            // Update boost timers
            Object.keys(gameState.activeBoosts).forEach(boost => {
                if (gameState.activeBoosts[boost] > 0) {
                    gameState.activeBoosts[boost]--;
                }
            });
            
            // Combo timer
            if (gameState.combo > 0) {
                gameState.comboTimer--;
                if (gameState.comboTimer <= 0) {
                    gameState.combo = 0;
                    gameState.multiplier = 1.0;
                }
            }
            
            // Regeneration
            if (upgrades.regeneration.level > 0 && gameState.lives < 10) {
                if (Math.random() < 0.001 * upgrades.regeneration.level) {
                    gameState.lives++;
                    createParticle(gameState.player.x + 25, gameState.player.y, 'coin', '#f5f5f5');
                }
            }
            
            // Spawn objects
            gameState.timers.plumSpawn++;
            const plumSpawnRate = Math.max(50, 150 - gameState.level * 3) * timeMultiplier;
            if (gameState.timers.plumSpawn > plumSpawnRate) {
                spawnPlum();
                gameState.timers.plumSpawn = 0;
            }
            
            gameState.timers.obstacleSpawn++;
            const obstacleSpawnRate = Math.max(40, 120 - gameState.level * 8) * timeMultiplier;
            if (gameState.timers.obstacleSpawn > obstacleSpawnRate) {
                spawnObstacle();
                gameState.timers.obstacleSpawn = 0;
            }
            
            // Level progression
            gameState.timers.levelUp++;
            const levelProgress = (gameState.timers.levelUp % 1800) / 1800;
            document.getElementById('levelProgress').style.width = (levelProgress * 100) + '%';
            
            if (gameState.timers.levelUp > 1800) {
                gameState.level++;
                gameState.timers.levelUp = 0;
                
                // Play level up sound
                playSound('levelUp', 0, 1.0, 0.5);
                
                for (let i = 0; i < 20; i++) {
                    createParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        'explosion',
                        '#f5f5f5'
                    );
                }
            }
            
            // Draw everything
            drawPlayer();
            gameState.plums.forEach(drawPlum);
            gameState.obstacles.forEach(drawObstacle);
            
            updateUI();
            saveGame();
            
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.multiplier = 1.0;
            gameState.comboTimer = 0;
            gameState.isRunning = true;
            gameState.sessionGames++;
            gameState.frameCount = 0;
            gameState.lastTime = performance.now();
            gameState.activeBoosts = {
                speed: 0,
                size: 0,
                magnet: 0,
                shield: 0,
                slowMotion: 0,
                cursed: 0
            };
            gameState.plums = [];
            gameState.obstacles = [];
            gameState.particles = [];
            gameState.splashParticles = [];
            gameState.timers = { plumSpawn: 0, obstacleSpawn: 0, specialSpawn: 0, levelUp: 0 };
            gameState.player = {
                x: 375,
                y: 520,
                width: 50,
                height: 30,
                speed: 5,
                invulnerable: 0
            };
            
            applyUpgrades();
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('upgradeScreen').style.display = 'none';
            
            // Initialize audio and start ambient sounds
            if (!audioContext) {
                initAudio();
            }
            if (audioContext) {
                setTimeout(playAmbientTone, 1000); // Start ambient after 1 second
            }
            
            gameLoop();
        }
        
        function endGame() {
            gameState.isRunning = false;
            const coinsEarned = Math.floor(gameState.score / 20);
            gameState.coins += coinsEarned;
            gameState.totalCoins += coinsEarned;
            gameState.lifetimeCoins += coinsEarned;
            
            // Update high scores
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
            }
            if (gameState.maxCombo > gameState.highCombo) {
                gameState.highCombo = gameState.maxCombo;
            }
            if (gameState.score > gameState.sessionBest) {
                gameState.sessionBest = gameState.score;
            }
            
            saveGame();
            
            document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
            document.getElementById('coinsEarned').textContent = coinsEarned.toLocaleString();
            document.getElementById('bestCombo').textContent = gameState.maxCombo;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function showUpgrades() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('upgradeScreen').style.display = 'block';
            document.getElementById('totalCoins').textContent = gameState.coins.toLocaleString();
            
            const upgradeList = document.getElementById('upgradeList');
            upgradeList.innerHTML = '';
            
            // Group upgrades by category
            const categories = {};
            Object.keys(upgradeData).forEach(key => {
                const category = upgradeData[key].category;
                if (!categories[category]) categories[category] = [];
                categories[category].push(key);
            });
            
            Object.keys(categories).forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'upgrade-category';
                categoryDiv.innerHTML = `<h3>◈ ${category.toUpperCase()} SYSTEMS ◈</h3>`;
                
                categories[category].forEach(key => {
                    const upgrade = upgradeData[key];
                    const level = upgrades[key].level;
                    const maxLevel = upgrades[key].maxLevel;
                    const cost = Math.floor(upgrade.baseCost * Math.pow(1.6, level));
                    
                    const div = document.createElement('div');
                    
                    if (level >= maxLevel) {
                        div.className = 'upgrade-item maxed';
                        div.innerHTML = `
                            <div class="upgrade-description">
                                <div class="upgrade-name">${upgrade.name}</div>
                                <div class="upgrade-effect">${upgrade.description}</div>
                                <div class="upgrade-level">MAXED OUT [${level}/${maxLevel}]</div>
                            </div>
                            <div class="upgrade-cost">◼ COMPLETE ◼</div>
                        `;
                    } else {
                        div.className = `upgrade-item ${gameState.coins >= cost ? 'affordable' : 'unaffordable'}`;
                        div.innerHTML = `
                            <div class="upgrade-description">
                                <div class="upgrade-name">${upgrade.name}</div>
                                <div class="upgrade-effect">${upgrade.description}</div>
                                <div class="upgrade-level">Level: ${level}/${maxLevel}</div>
                            </div>
                            <div class="upgrade-cost">${cost.toLocaleString()}</div>
                        `;
                        
                        if (gameState.coins >= cost) {
                            div.onclick = () => buyUpgrade(key, cost);
                        }
                    }
                    
                    categoryDiv.appendChild(div);
                });
                
                upgradeList.appendChild(categoryDiv);
            });
        }
        
        function buyUpgrade(key, cost) {
            if (gameState.coins >= cost && upgrades[key].level < upgrades[key].maxLevel) {
                gameState.coins -= cost;
                upgrades[key].level++;
                
                saveGame();
                
                // Purchase effect
                for (let i = 0; i < 15; i++) {
                    createParticle(400, 300, 'coin', '#f5f5f5');
                }
                
                showUpgrades(); // Refresh the upgrade screen
            }
        }
        
        function hideUpgrades() {
            document.getElementById('upgradeScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Initialize game
        loadGame();
        applyUpgrades();
        updateUI();
        startGame();
    </script>
    </div>
</body>
</html>
